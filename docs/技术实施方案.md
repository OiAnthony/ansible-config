## æŠ€æœ¯æ–¹æ¡ˆï¼šä½¿ç”¨ Ansible è‡ªåŠ¨åŒ–å¼€å‘ç¯å¢ƒ

### 1. æ ¸å¿ƒæ€è·¯

* **Ansible Roles**: å°†æ¯ä¸€ç±»è½¯ä»¶æˆ–é…ç½®ï¼ˆå¦‚ zsh, python, nodejsï¼‰å°è£…æˆç‹¬ç«‹çš„ Ansible Roleï¼Œæ–¹ä¾¿ç®¡ç†å’Œå¤ç”¨ã€‚
* **Inventory**: ç®¡ç†ä½ çš„ macOS å’Œ VPS ä¸»æœºã€‚å¯¹äºæ–°æœºå™¨ï¼Œé€šå¸¸æ˜¯åœ¨æœ¬æœºè¿è¡Œ Ansible Playbookï¼ˆ`connection: local`ï¼‰ã€‚
* **OS Detection**: Playbook éœ€è¦èƒ½å¤Ÿæ£€æµ‹æ“ä½œç³»ç»Ÿ (macOS vs Ubuntu) å¹¶æ‰§è¡Œç›¸åº”çš„ä»»åŠ¡ã€‚
* **Idempotency**: Ansible çš„æ ¸å¿ƒç‰¹æ€§ï¼Œç¡®ä¿å¤šæ¬¡è¿è¡Œè„šæœ¬ç»“æœä¸€è‡´ï¼Œä¸ä¼šé‡å¤å®‰è£…æˆ–é”™è¯¯ä¿®æ”¹é…ç½®ã€‚
* **Variables**: ä½¿ç”¨å˜é‡æ¥ç®¡ç†æ’ä»¶åˆ—è¡¨ã€ç‰ˆæœ¬å·ç­‰ï¼Œæ–¹ä¾¿è‡ªå®šä¹‰ã€‚
* **Git Repository**: å°†æ‰€æœ‰ Ansible é…ç½®å­˜æ”¾åœ¨ GitHub ä»“åº“ä¸­ã€‚

### 2. é¡¹ç›®ç»“æ„ (Git Repo)

```
repo/
â”œâ”€â”€ ansible.cfg                # Ansible é…ç½®æ–‡ä»¶
â”œâ”€â”€ inventory.ini              # ä¸»æœºæ¸…å• (ä¸»è¦ç”¨äºæœ¬åœ°æ‰§è¡Œ)
â”œâ”€â”€ playbook.yml               # ä¸» Playbookï¼Œè°ƒç”¨ Roles
â”œâ”€â”€ requirements.yml           # Ansible Galaxy ä¾èµ– (å¯é€‰, å¦‚ç¤¾åŒº roles)
â”œâ”€â”€ bootstrap.sh               # (å¯é€‰) æœ¬åœ°å¼•å¯¼è„šæœ¬ï¼Œç”¨äºå®‰è£… Ansible å¹¶è¿è¡Œ Playbook
â”œâ”€â”€ README.md                  # é¡¹ç›®è¯´æ˜
â”‚
â””â”€â”€ roles/
    â”œâ”€â”€ common/                # é€šç”¨é…ç½®å’ŒåŸºç¡€åŒ… (git, curl, build-essentialsç­‰)
    â”‚   â”œâ”€â”€ tasks/
    â”‚   â”‚   â”œâ”€â”€ main.yml
    â”‚   â”‚   â”œâ”€â”€ debian.yml     # Ubuntu specific tasks
    â”‚   â”‚   â””â”€â”€ darwin.yml     # macOS specific tasks
    â”‚   â””â”€â”€ vars/
    â”‚       â””â”€â”€ main.yml
    â”‚
    â”œâ”€â”€ zsh/
    â”‚   â”œâ”€â”€ tasks/
    â”‚   â”‚   â”œâ”€â”€ main.yml
    â”‚   â”‚   â”œâ”€â”€ oh_my_zsh.yml
    â”‚   â”‚   â””â”€â”€ starship.yml
    â”‚   â”œâ”€â”€ templates/
    â”‚   â”‚   â””â”€â”€ zshrc.j2       # .zshrc æ¨¡æ¿
    â”‚   â””â”€â”€ vars/
    â”‚       â””â”€â”€ main.yml       # zsh_plugins åˆ—è¡¨ç­‰
    â”‚
    â”œâ”€â”€ python/
    â”‚   â”œâ”€â”€ tasks/
    â”‚   â”‚   â”œâ”€â”€ main.yml
    â”‚   â”‚   â””â”€â”€ miniforge.yml
    â”‚   â””â”€â”€ vars/
    â”‚       â””â”€â”€ main.yml
    â”‚
    â”œâ”€â”€ nodejs/
    â”‚   â”œâ”€â”€ tasks/
    â”‚   â”‚   â”œâ”€â”€ main.yml
    â”‚   â”‚   â””â”€â”€ volta.yml
    â”‚   â””â”€â”€ vars/
    â”‚       â””â”€â”€ main.yml
    â”‚
    â””â”€â”€ tools/                 # å…¶ä»–å·¥å…· (docker, etc.)
        â”œâ”€â”€ tasks/
        â”‚   â””â”€â”€ main.yml
        â””â”€â”€ vars/
            â””â”€â”€ main.yml
```

### 3. å…³é”®æ–‡ä»¶è¯¦è§£

#### a. `ansible.cfg`

```ini
[defaults]
inventory = inventory.ini
roles_path = ./roles
host_key_checking = False
deprecation_warnings = False
# å¦‚æœä½ ç»å¸¸åœ¨æœ¬åœ°è¿è¡Œï¼Œå¯ä»¥è®¾ç½®é»˜è®¤ interpreter
# interpreter_python = auto_silent

[privilege_escalation]
become = True
become_method = sudo
become_user = root
# become_ask_pass = False # å¦‚æœä½ é…ç½®äº†å…å¯† sudoï¼Œå¯ä»¥è®¾ä¸º False
```

#### b. `inventory.ini`

ä¸»è¦ç”¨äºåœ¨ç›®æ ‡æœºå™¨ä¸Šæœ¬åœ°æ‰§è¡Œã€‚

```ini
[local]
localhost ansible_connection=local ansible_python_interpreter="{{ansible_playbook_python}}"

# å¦‚æœä½ æƒ³è¿œç¨‹ç®¡ç†å…¶ä»–æœºå™¨ï¼Œå¯ä»¥è¿™æ ·æ·»åŠ ï¼š
# [vps_servers]
# server1.example.com
# server2.example.com

# [macos_machines]
# mymac.local
```

`ansible_python_interpreter="{{ansible_playbook_python}}"` ç¡®ä¿æœ¬åœ°æ‰§è¡Œæ—¶ä½¿ç”¨ä¸ Ansible æ§åˆ¶èŠ‚ç‚¹ç›¸åŒçš„ Python è§£é‡Šå™¨ã€‚

#### c. `playbook.yml`

è¿™æ˜¯ä¸»å…¥å£æ–‡ä»¶ã€‚

```yaml
---
- name: Setup Development Environment
  hosts: local # æˆ–è€… all, group_name, å…·ä½“å–å†³äºä½ çš„ inventory å’Œç›®æ ‡
  gather_facts: true # æ”¶é›†ç›®æ ‡æœºå™¨ä¿¡æ¯ï¼Œå¦‚ os_family

  vars:
    # ç”¨æˆ·åä¼šè‡ªåŠ¨è·å–å½“å‰æ‰§è¡Œ playbook çš„ç”¨æˆ· (ansible_user_id)
    # å¯¹äºè¿œç¨‹ä¸»æœºï¼Œä¼šä½¿ç”¨ SSH è¿æ¥çš„ç”¨æˆ·
    target_user: "{{ ansible_user_id }}"
    user_home: "{{ ansible_env.HOME if ansible_connection == 'local' else '/home/' + target_user if ansible_os_family == 'Debian' else '/Users/' + target_user }}"

  roles:
    - role: common
    - role: zsh
      vars:
        # è¦†ç›– zsh role ä¸­çš„é»˜è®¤æ’ä»¶åˆ—è¡¨
        zsh_plugins_list:
          - git
          - extract
          - z
          - fzf
          - history
          - zsh-autosuggestions
          - zsh-syntax-highlighting
          - tmux
          - uv
          - pdm
          - bun
          - volta
          - docker
          - docker-compose
          - sudo
    - role: python
    - role: nodejs
    # - role: tools # å¦‚æœæœ‰å…¶ä»–å·¥å…·
```

#### d. `requirements.yml` (å¯é€‰)

å¦‚æœä½ ä½¿ç”¨æ¥è‡ª Ansible Galaxy çš„ Rolesï¼ˆä¾‹å¦‚ï¼Œä¸€ä¸ªæ›´å®Œå–„çš„ Docker Roleï¼‰ï¼Œå¯ä»¥åœ¨è¿™é‡Œå®šä¹‰ã€‚

```yaml
# roles:
#   - name: geerlingguy.docker
#     version: "6.1.0" # æŒ‡å®šç‰ˆæœ¬
```

ç„¶åè¿è¡Œ `ansible-galaxy install -r requirements.yml` ä¸‹è½½ã€‚

#### e. `bootstrap.sh` (å¯é€‰ï¼Œç”¨äºæ–°æœºé¦–æ¬¡è¿è¡Œ)

è¿™ä¸ªè„šæœ¬ç®€åŒ–äº†åœ¨æ–°æœºå™¨ä¸Šé¦–æ¬¡è¿è¡Œçš„æµç¨‹ã€‚

```bash
#!/bin/bash

set -e # Exit immediately if a command exits with a non-zero status.

echo "ğŸš€ Bootstrapping Development Environment Setup..."

# --- Helper Functions ---
check_command() {
  command -v "$1" >/dev/null 2>&1
}

install_package_manager_if_needed() {
  if [[ "$(uname)" == "Darwin" ]]; then
    if ! check_command brew; then
      echo "ğŸº Homebrew not found. Installing Homebrew..."
      /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
      # Add Homebrew to PATH for the current session
      if [[ -x "/opt/homebrew/bin/brew" ]]; then # Apple Silicon
          eval "$(/opt/homebrew/bin/brew shellenv)"
      else # Intel
          eval "$(/usr/local/bin/brew shellenv)"
      fi
    else
      echo "ğŸº Homebrew already installed."
    fi
    # Ensure core utils for ansible, like python3 and pip3
    if ! check_command python3 || ! check_command pip3; then
        echo "ğŸ Installing Python3 via Homebrew..."
        brew install python3
    fi
  elif [[ "$(uname -s)" == "Linux" ]]; then
    if check_command apt-get; then
      echo "ğŸ”§ Ensuring prerequisites for Ansible on Debian/Ubuntu..."
      sudo apt-get update
      sudo apt-get install -y software-properties-common python3 python3-pip git curl
    elif check_command yum; then
      echo "ğŸ”§ Ensuring prerequisites for Ansible on RHEL/CentOS..."
      sudo yum install -y python3 python3-pip git curl
    else
      echo "Unsupported Linux distribution for automatic prerequisite installation."
      exit 1
    fi
  else
    echo "Unsupported OS for automatic prerequisite installation."
    exit 1
  fi
}

install_ansible_if_needed() {
  if ! check_command ansible; then
    echo "Installing Ansible..."
    python3 -m pip install --user ansible
    # Add Ansible to PATH if installed with --user
    if [[ "$(uname)" == "Darwin" ]]; then
      export PATH="$HOME/Library/Python/$(python3 -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")')/bin:$PATH"
    else
      export PATH="$HOME/.local/bin:$PATH"
    fi
    if ! check_command ansible; then
        echo "Ansible installation failed or not in PATH. Please check."
        exit 1
    fi
  else
    echo "âœ… Ansible already installed."
  fi
}

# --- Main Logic ---

# 1. Install package manager (Homebrew on macOS) and Python/Git if not present
install_package_manager_if_needed

# 2. Install Ansible if not present
install_ansible_if_needed

# 3. Clone or update your dev-env repository
REPO_DIR="$HOME/my-dev-env" # Or wherever you prefer
REPO_URL="https://github.com/YOUR_USERNAME/YOUR_REPO_NAME.git" # CHANGE THIS

if [ -d "$REPO_DIR" ]; then
  echo "ğŸ”„ Updating dev-env repository in $REPO_DIR..."
  cd "$REPO_DIR"
  git pull
else
  echo "ğŸ“¥ Cloning dev-env repository to $REPO_DIR..."
  git clone "$REPO_URL" "$REPO_DIR"
  cd "$REPO_DIR"
fi

# 4. (Optional) Install Ansible Galaxy requirements
if [ -f "requirements.yml" ]; then
  echo "ğŸŒŒ Installing Ansible Galaxy roles..."
  ansible-galaxy install -r requirements.yml
fi

# 5. Run the Ansible playbook
echo "âš™ï¸ Running Ansible playbook..."
# Use --ask-become-pass if your user needs to enter a password for sudo
# If you have passwordless sudo, you can remove --ask-become-pass
ansible-playbook playbook.yml --ask-become-pass

echo "âœ… Development Environment setup process complete!"
echo "â„¹ï¸  You may need to restart your terminal or source your .zshrc for all changes to take effect."
```

**é‡è¦**:

1. ä¿®æ”¹ `REPO_URL` ä¸ºä½ çš„ GitHub ä»“åº“åœ°å€ã€‚
2. ç”¨æˆ·éœ€è¦ `git clone` è¿™ä¸ªä»“åº“ï¼Œç„¶åè¿è¡Œ `bash bootstrap.sh`ã€‚æˆ–è€…ä½ ç›´æ¥åœ¨æ–°æœºå™¨ä¸Š `curl -L your-bootstrap-script-url | bash`ã€‚

### 4. Role ç¼–å†™ç¤ºä¾‹

#### a. `roles/common/tasks/main.yml`

```yaml
---
- name: Include OS-specific tasks for common setup
  ansible.builtin.include_tasks: "{{ ansible_os_family | lower }}.yml"

- name: Ensure .config directory exists
  ansible.builtin.file:
    path: "{{ user_home }}/.config"
    state: directory
    mode: '0755'
  become: false # Usually user's home directory operations don't need sudo

# Add any other truly common tasks here
```

#### b. `roles/common/tasks/debian.yml` (Ubuntu)

```yaml
---
- name: Update apt cache (Ubuntu)
  ansible.builtin.apt:
    update_cache: true
    cache_valid_time: 3600 # Cache for 1 hour
  become: true
  when: ansible_os_family == "Debian"

- name: Install common packages (Ubuntu)
  ansible.builtin.apt:
    name:
      - git
      - curl
      - wget
      - build-essential # For compiling software
      - apt-transport-https
      - ca-certificates
      - gnupg
      - lsb-release
      - software-properties-common
      - htop
      - tree
      - unzip
      - fzf # Needed for zsh plugin
    state: present
  become: true
  when: ansible_os_family == "Debian"
```

#### c. `roles/common/tasks/darwin.yml` (macOS)

```yaml
---
- name: Ensure Homebrew is installed (macOS)
  ansible.builtin.stat:
    path: "{{ '/opt/homebrew/bin/brew' if ansible_architecture == 'arm64' else '/usr/local/bin/brew' }}"
  register: brew_check

- name: Install Homebrew (macOS)
  ansible.builtin.shell:
    cmd: /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    creates: "{{ '/opt/homebrew/bin/brew' if ansible_architecture == 'arm64' else '/usr/local/bin/brew' }}"
  when: not brew_check.stat.exists
  become: false # Homebrew installation script handles sudo if needed, or installs to user dir

- name: Update Homebrew (macOS)
  community.general.homebrew:
    update_homebrew: true
  when: ansible_os_family == "Darwin"
  become: false

- name: Install common packages (macOS)
  community.general.homebrew:
    name:
      - git
      - curl
      - wget
      - htop
      - tree
      - fzf # Needed for zsh plugin
    state: present
  when: ansible_os_family == "Darwin"
  become: false # Homebrew installs packages for the user
```

*Note: For Homebrew on macOS, `become: false` is generally correct as Homebrew manages its own permissions or installs into user-writable locations. The Ansible Homebrew module handles this well.*

#### d. `roles/zsh/vars/main.yml`

```yaml
---
# Default list of Oh My Zsh plugins
# This can be overridden in playbook.yml or group_vars/host_vars
zsh_plugins_list:
  - git
  - extract
  - z
  - fzf
  - history
  - zsh-autosuggestions
  - zsh-syntax-highlighting
  - sudo

oh_my_zsh_repo: "https://github.com/ohmyzsh/ohmyzsh.git"
oh_my_zsh_path: "{{ user_home }}/.oh-my-zsh"

# Custom plugins base path
oh_my_zsh_custom_plugins_path: "{{ oh_my_zsh_path }}/custom/plugins"

# Specific custom plugins repositories
zsh_autosuggestions_repo: "https://github.com/zsh-users/zsh-autosuggestions"
zsh_syntax_highlighting_repo: "https://github.com/zsh-users/zsh-syntax-highlighting"
```

#### e. `roles/zsh/tasks/main.yml`

```yaml
---
- name: Install Zsh
  ansible.builtin.package:
    name: zsh
    state: present
  become: true

- name: Include Oh My Zsh installation tasks
  ansible.builtin.include_tasks: oh_my_zsh.yml

- name: Include Starship installation tasks
  ansible.builtin.include_tasks: starship.yml

- name: Change user's default shell to Zsh
  ansible.builtin.user:
    name: "{{ target_user }}"
    shell: "{{ '/bin/zsh' if ansible_os_family == 'Debian' else '/usr/local/bin/zsh' if ansible_os_family == 'Darwin' and ansible_architecture != 'arm64' else '/opt/homebrew/bin/zsh' if ansible_os_family == 'Darwin' and ansible_architecture == 'arm64' else '/bin/zsh' }}" # Adjust path as needed
  become: true
  # Note: Changing shell might require logout/login to take effect.
  # For local execution, this might not immediately reflect in the current terminal.
```

#### f. `roles/zsh/tasks/oh_my_zsh.yml`

```yaml
---
- name: Check if Oh My Zsh is already installed
  ansible.builtin.stat:
    path: "{{ oh_my_zsh_path }}"
  register: oh_my_zsh_check
  become: false # Check runs as user

- name: Install Oh My Zsh
  ansible.builtin.shell:
    cmd: >
      sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
    creates: "{{ oh_my_zsh_path }}/oh-my-zsh.sh" # Idempotency check
  environment: # Pass environment variables to the script
    ZSH: "{{ oh_my_zsh_path }}"
    RUNZSH: "no" # Don't start zsh after install
    CHSH: "no"   # Don't change shell automatically, Ansible will do it
  become: false # Run as target_user
  when: not oh_my_zsh_check.stat.exists

- name: Clone zsh-autosuggestions plugin
  ansible.builtin.git:
    repo: "{{ zsh_autosuggestions_repo }}"
    dest: "{{ oh_my_zsh_custom_plugins_path }}/zsh-autosuggestions"
    version: master # Or a specific tag/commit
  become: false

- name: Clone zsh-syntax-highlighting plugin
  ansible.builtin.git:
    repo: "{{ zsh_syntax_highlighting_repo }}"
    dest: "{{ oh_my_zsh_custom_plugins_path }}/zsh-syntax-highlighting"
    version: master
  become: false

- name: Configure .zshrc with plugins
  ansible.builtin.template:
    src: zshrc.j2
    dest: "{{ user_home }}/.zshrc"
    owner: "{{ target_user }}"
    group: "{{ target_user if ansible_os_family == 'Darwin' else target_user }}" # Group might be different on Linux
    mode: '0644'
  become: false # .zshrc is user-specific
```

#### g. `roles/zsh/templates/zshrc.j2`

```jinja2
# Path to your oh-my-zsh installation.
export ZSH="{{ oh_my_zsh_path }}"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time oh-my-zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="robbyrussell" # Or your preferred theme, e.g., "agnoster", or "" if using Starship

# Oh My Zsh plugins
plugins=(
  {% for plugin in zsh_plugins_list %}
  {{ plugin }}
  {% endfor %}
)

source $ZSH/oh-my-zsh.sh

# User configuration
export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For example, you can see examples of adding aliases to $ZSH_CUSTOM/aliases.zsh
# (then uncomment themes/robbyrussell/robbyrussell.zsh_theme).
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

# Starship prompt (if installed)
# Make sure this is at the end of your .zshrc
# Check if starship role has a variable starship_installed, or check binary path
# This is a simplified check. A more robust way is to set a fact in starship.yml
# and use that fact here. For simplicity, we'll assume starship is installed.
if command -v starship &> /dev/null; then
  eval "$(starship init zsh)"
fi

# Volta (if installed by nodejs role)
export VOLTA_HOME="$HOME/.volta"
export PATH="$VOLTA_HOME/bin:$PATH"

# Miniforge/Conda (if installed by python role)
# This path might need to be dynamic based on miniforge role's installation path
# It's better if the miniforge role adds this to a shell profile fragment
# or if you know the exact path.
# For example, if miniforge is installed to {{ user_home }}/miniforge3
_CONDA_ROOT="{{ user_home }}/miniforge3" # Adjust if your miniforge role installs elsewhere
if [ -f "${_CONDA_ROOT}/etc/profile.d/conda.sh" ]; then
    . "${_CONDA_ROOT}/etc/profile.d/conda.sh"
else
    export PATH="${_CONDA_ROOT}/bin:$PATH"
fi
# You might want to 'conda activate base' by default or not.
# conda activate base
```

**Important for `.zshrc`**:
The order of sourcing/initialization matters. Volta, Conda, Starship initializations should typically come *after* `source $ZSH/oh-my-zsh.sh` but *before* any custom user aliases or functions that might depend on them.
Starship's `eval "$(starship init zsh)"` should be one of the last things.

#### h. `roles/zsh/tasks/starship.yml`

```yaml
---
- name: Check if Starship is already installed
  ansible.builtin.command: starship --version
  register: starship_check
  changed_when: false
  failed_when: false # Don't fail if command not found
  become: false

- name: Install Starship
  ansible.builtin.shell:
    cmd: curl -sS https://starship.rs/install.sh | sh -s -- -y
    # creates: "{{ user_home }}/.cargo/bin/starship" # Path might vary depending on install method and OS
  args:
    # Check if the specific binary starship creates exists
    # For macOS using Homebrew: /opt/homebrew/bin/starship or /usr/local/bin/starship
    # For Linux from script: /usr/local/bin/starship typically
    # This is tricky as the script can install to different locations.
    # A better 'creates' would be based on the known installation path for your method.
    # For now, rely on starship_check.rc != 0
    creates: "{{ '/opt/homebrew/bin/starship' if ansible_os_family == 'Darwin' and ansible_architecture == 'arm64' else '/usr/local/bin/starship' if ansible_os_family == 'Darwin' else '/usr/local/bin/starship' }}" # Adjust path
  when: starship_check.rc != 0
  become_user: "{{ target_user }}" # Install script might need sudo internally, but run as user first
  become: true # Allow the script to use sudo if it needs to install to /usr/local/bin

- name: Ensure Starship config directory exists
  ansible.builtin.file:
    path: "{{ user_home }}/.config"
    state: directory
    mode: '0755'
  become: false

- name: Deploy Starship configuration (optional)
  ansible.builtin.copy:
    # content: |
    #   # Your starship.toml content here
    #   # Example:
    #   # [character]
    #   # success_symbol = "[âœ](bold green)"
    #   # error_symbol = "[âœ—](bold red)"
    # src: files/starship.toml # if you have a file
    dest: "{{ user_home }}/.config/starship.toml"
    mode: '0644'
  become: false
  # Add a 'content' or 'src' attribute here with your starship.toml
  # This task is a placeholder.
  notify: Reload Starship config (placeholder) # Not really a handler, just a note

# Note: The .zshrc template needs to include 'eval "$(starship init zsh)"'
```

*For `starship.toml`, you can use the `ansible.builtin.copy` module if you have a static file, or `ansible.builtin.template` if it needs variables.*

#### i. `roles/python/tasks/main.yml` & `miniforge.yml`

**`roles/python/tasks/main.yml`:**

```yaml
---
- name: Install prerequisites for Python (build tools, libffi etc)
  ansible.builtin.package:
    name: "{{ 'build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev python3-openssl' if ansible_os_family == 'Debian' else '' }}" # macOS handles this via brew generally or miniforge installer
    state: present
  become: true
  when: ansible_os_family == 'Debian' # On macOS, brew usually handles dependencies for python builds or they are part of XCode Command Line Tools

- name: Include Miniforge installation tasks
  ansible.builtin.include_tasks: miniforge.yml
```

**`roles/python/tasks/miniforge.yml`:**

```yaml
---
# Vars for miniforge (can be in roles/python/vars/main.yml)
# miniforge_installer_url_base: "https://github.com/conda-forge/miniforge/releases/latest/download"
# miniforge_version: "Miniforge3" # Or Miniforge3-MacOSX-arm64 etc.
# miniforge_os: "{{ 'Linux' if ansible_os_family == 'Debian' else 'MacOSX' }}"
# miniforge_arch: "{{ 'x86_64' if ansible_architecture == 'x86_64' else 'arm64' if ansible_architecture == 'arm64' and ansible_os_family == 'Darwin' else 'x86_64' }}" # Be more specific for arm64 Linux if needed
# miniforge_installer_sh: "{{ miniforge_version }}-{{ miniforge_os }}-{{ miniforge_arch }}.sh"
# miniforge_install_path: "{{ user_home }}/miniforge3"

- name: Determine Miniforge installer filename
  ansible.builtin.set_fact:
    miniforge_installer_sh: >-
      {%- if ansible_os_family == 'Darwin' and ansible_architecture == 'arm64' -%}
      Miniforge3-MacOSX-arm64.sh
      {%- elif ansible_os_family == 'Darwin' and ansible_architecture == 'x86_64' -%}
      Miniforge3-MacOSX-x86_64.sh
      {%- elif ansible_os_family == 'Debian' and ansible_architecture == 'aarch64' or ansible_architecture == 'arm64' -%}
      Miniforge3-Linux-aarch64.sh
      {%- elif ansible_os_family == 'Debian' and ansible_architecture == 'x86_64' -%}
      Miniforge3-Linux-x86_64.sh
      {%- else -%}
      {{ ansible_env.NA }} # This will cause a failure, which is good.
      {%- endif -%}
    miniforge_install_path: "{{ user_home }}/miniforge3"

- name: Check if Miniforge is already installed
  ansible.builtin.stat:
    path: "{{ miniforge_install_path }}/bin/conda"
  register: miniforge_check
  become: false

- name: Download Miniforge installer
  ansible.builtin.get_url:
    url: "https://github.com/conda-forge/miniforge/releases/latest/download/{{ miniforge_installer_sh }}"
    dest: "/tmp/{{ miniforge_installer_sh }}"
    mode: '0755'
  when: not miniforge_check.stat.exists
  become: false

- name: Install Miniforge
  ansible.builtin.shell:
    cmd: "bash /tmp/{{ miniforge_installer_sh }} -b -p {{ miniforge_install_path }}"
    creates: "{{ miniforge_install_path }}/bin/conda" # Idempotency
  when: not miniforge_check.stat.exists
  become: false # Install in user's home

- name: Ensure Miniforge is on the PATH in .zshrc (idempotent block)
  ansible.builtin.blockinfile:
    path: "{{ user_home }}/.zshrc"
    block: |
      # Conda/Miniforge
      export PATH="{{ miniforge_install_path }}/bin:$PATH"
      # The following lines are managed by 'conda init' and might be added automatically
      # If you want conda init to run, you could do that instead, but it's more invasive.
      # For just PATH, this is fine. For full conda shell functions, conda init is better.
      # if [ -f "{{ miniforge_install_path }}/etc/profile.d/conda.sh" ]; then
      #     . "{{ miniforge_install_path }}/etc/profile.d/conda.sh"
      # else
      #     export PATH="{{ miniforge_install_path }}/bin:$PATH"
      # fi
    create: true # Create .zshrc if it doesn't exist (though zsh role should handle this)
    marker: "# {mark} ANSIBLE MANAGED BLOCK CONDA"
  become: false

# Optionally, run conda init for zsh after installation
- name: Initialize Conda for Zsh
  ansible.builtin.command: "{{ miniforge_install_path }}/bin/conda init zsh"
  changed_when: true # conda init usually modifies files
  when: not miniforge_check.stat.exists # Run only on fresh install
  become: false
  environment:
    PATH: "{{ miniforge_install_path }}/bin:{{ ansible_env.PATH }}"

# Clean up installer
- name: Remove Miniforge installer
  ansible.builtin.file:
    path: "/tmp/{{ miniforge_installer_sh }}"
    state: absent
  when: not miniforge_check.stat.exists # Only if we downloaded it
  become: false
```

*The `conda init zsh` command will modify your `.zshrc` to properly source conda's shell functions. This is generally preferred over just adding to PATH for full conda functionality.*

#### j. `roles/nodejs/tasks/main.yml` & `volta.yml`

**`roles/nodejs/tasks/main.yml`:**

```yaml
---
- name: Install curl and other prerequisites for Volta (if not already handled by 'common' role)
  ansible.builtin.package:
    name: "{{ 'curl' if ansible_os_family == 'Debian' else '' }}" # macOS has curl by default
    state: present
  become: true
  when: ansible_os_family == 'Debian'

- name: Include Volta installation and Node.js/pnpm setup
  ansible.builtin.include_tasks: volta.yml
```

**`roles/nodejs/tasks/volta.yml`:**

```yaml
---
- name: Define Volta paths
  ansible.builtin.set_fact:
    volta_home: "{{ user_home }}/.volta"
    volta_bin_path: "{{ user_home }}/.volta/bin"

- name: Check if Volta is already installed
  ansible.builtin.stat:
    path: "{{ volta_bin_path }}/volta"
  register: volta_check
  become: false

- name: Install Volta
  ansible.builtin.shell:
    # The official installer sets up PATH in shell profiles automatically
    cmd: curl https://get.volta.sh | bash
    creates: "{{ volta_bin_path }}/volta" # Idempotency
  environment:
    VOLTA_HOME: "{{ volta_home }}" # Ensure it installs to the right place if script uses it
  when: not volta_check.stat.exists
  become: false # Volta installs to user's home

# Volta's installer should add itself to .zshrc, but let's ensure it
- name: Ensure Volta is on the PATH in .zshrc (idempotent block)
  ansible.builtin.blockinfile:
    path: "{{ user_home }}/.zshrc"
    block: |
      # Volta
      export VOLTA_HOME="{{ user_home }}/.volta"
      export PATH="$VOLTA_HOME/bin:$PATH"
    create: true
    marker: "# {mark} ANSIBLE MANAGED BLOCK VOLTA"
  become: false

# The following tasks need Volta in PATH.
# For the current Ansible run, PATH might not be updated yet.
# So we prepend Volta's bin dir to the command or use `environment`.

- name: Install Node.js (LTS) using Volta
  ansible.builtin.command: "{{ volta_bin_path }}/volta install node" # Installs latest LTS by default
  # To install a specific version: volta install node@18
  changed_when: true # Assume it changes unless we check current version
  when: volta_check.stat.exists or not volta_check.stat.exists # Run if Volta just got installed OR was already there
  become: false
  environment:
    VOLTA_HOME: "{{ volta_home }}"
    PATH: "{{ volta_bin_path }}:{{ ansible_env.PATH }}" # Critical for subsequent volta commands in same play

- name: Install pnpm using Volta
  ansible.builtin.command: "{{ volta_bin_path }}/volta install pnpm"
  changed_when: true
  when: volta_check.stat.exists or not volta_check.stat.exists
  become: false
  environment:
    VOLTA_HOME: "{{ volta_home }}"
    PATH: "{{ volta_bin_path }}:{{ ansible_env.PATH }}"
```

### 5. ä½¿ç”¨æ–¹æ³•

1. **é¦–æ¬¡åœ¨æ–°æœºå™¨ä¸Š**:
    * ç¡®ä¿æ–°æœºå™¨æœ‰ `git` å’Œ `python3` (ä»¥åŠ `pip`). `bootstrap.sh` å°è¯•å¤„ç†è¿™ä¸ªã€‚
    * `git clone https://github.com/YOUR_USERNAME/YOUR_REPO_NAME.git my-dev-env`
    * `cd my-dev-env`
    * `(å¯é€‰)` ä¿®æ”¹ `playbook.yml` ä¸­çš„ `target_user` å¦‚æœéœ€è¦ï¼Œæˆ– `inventory.ini`ã€‚
    * è¿è¡Œå¼•å¯¼è„šæœ¬: `bash bootstrap.sh`
        * è¿™ä¸ªè„šæœ¬ä¼šå°è¯•å®‰è£… Ansible (å¦‚æœéœ€è¦) å¹¶è¿è¡Œ `ansible-playbook playbook.yml --ask-become-pass`ã€‚
        * `--ask-become-pass` ä¼šæç¤ºä½ è¾“å…¥ sudo å¯†ç ã€‚å¦‚æœä½ çš„ç”¨æˆ·æœ‰å…å¯† sudo æƒé™ï¼Œå¯ä»¥å»æ‰è¿™ä¸ªå‚æ•° (å¹¶ä¿®æ”¹ `bootstrap.sh` å’Œ `ansible.cfg`)ã€‚

2. **æ›´æ–°ç¯å¢ƒæˆ–åœ¨å·²é…ç½®æœºå™¨ä¸Šè¿è¡Œ**:
    * `cd my-dev-env`
    * `git pull` # è·å–æœ€æ–°é…ç½®
    * `ansible-playbook playbook.yml --ask-become-pass` (æˆ–è€…ä¸å¸¦ `--ask-become-pass` å¦‚æœæœ‰å…å¯† sudo)

### 6. è¿›ä¸€æ­¥çš„è€ƒè™‘å’Œæ”¹è¿›

* **Secrets Management**: å¦‚æœéœ€è¦å¤„ç† API å¯†é’¥ç­‰æ•æ„Ÿä¿¡æ¯ï¼Œä½¿ç”¨ Ansible Vaultã€‚
* **Homebrew on Linux (Linuxbrew)**: å¦‚æœä½ æƒ³åœ¨ Ubuntu VPS ä¸Šä¹Ÿç”¨ Homebrew ç®¡ç†æŸäº›åŒ…ä»¥ä¿æŒä¸€è‡´æ€§ï¼Œå¯ä»¥æ·»åŠ ç›¸åº”çš„é€»è¾‘ã€‚ä½†é€šå¸¸ VPS ä¸Šä½¿ç”¨ç³»ç»ŸåŒ…ç®¡ç†å™¨ (`apt`) æ›´å¸¸è§ã€‚
* **Dotfiles Management**: ä½ å¯èƒ½è¿˜æœ‰å…¶ä»–çš„ dotfiles (`.gitconfig`, `.vimrc`, etc.)ã€‚å¯ä»¥åˆ›å»ºä¸€ä¸ª `dotfiles` role æ¥ç®¡ç†å®ƒä»¬ï¼Œä½¿ç”¨ `copy` or `template` æ¨¡å—ã€‚
* **Testing**: Ğ”Ğ»Ñ Ğ±Ğ¾Ğ»ĞµĞµ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¹ Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚Ğµ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Molecule Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ²Ğ°ÑˆĞ¸Ñ… Ñ€Ğ¾Ğ»ĞµĞ¹ Ansible.
* **Tags**: ä¸º Playbook ä¸­çš„ä»»åŠ¡æˆ– Role æ·»åŠ æ ‡ç­¾ï¼Œè¿™æ ·å¯ä»¥åªè¿è¡Œéƒ¨åˆ†é…ç½®ã€‚ä¾‹å¦‚ï¼Œåªæ›´æ–° zsh é…ç½®: `ansible-playbook playbook.yml --tags zsh --ask-become-pass`ã€‚

    ```yaml
    # In roles/zsh/tasks/main.yml
    - name: Install Zsh
      ansible.builtin.package:
        name: zsh
        state: present
      become: true
      tags:
        - zsh
        - zsh_install
    ```

* **Handlers**: å¯¹äºéœ€è¦é‡å¯æœåŠ¡æˆ–é‡æ–°åŠ è½½é…ç½®çš„æ“ä½œï¼ˆä¸å¸¸è§äºæ­¤ç±»ç”¨æˆ·ç¯å¢ƒé…ç½®ï¼Œä½†å¯èƒ½ç”¨äºå¦‚ `systemd` æœåŠ¡ï¼‰ï¼Œå¯ä»¥ä½¿ç”¨ handlersã€‚
* **Error Handling and Verbosity**: è¿è¡Œ `ansible-playbook -vvv ...` è·å–æ›´è¯¦ç»†çš„è¾“å‡ºè¿›è¡Œè°ƒè¯•ã€‚
